# (四) select多路复用

❓问题 : 如何增强服务端能力,同时支持多个客户端?

# 1.Linux设计哲学 : 一切皆文件

><img src="./assets/image-20230812185704878.png" alt="image-20230812185704878" />

## 1.1 Linux 中的文件是什么?

>- 狭义：
>   - 文件系统中物理意义上的文件 (逻辑上关联的数据集合)
>- 广义：
>   - 设备 , 管道 , 内存 , 。。。
>   - Linux管理的一切对象
>

## 1.2 理解文件描述符 ( `File Descriptor` )

>- 文件描述符是一个 `非负整数值` , 本质是一个句柄
>- **$\color{red}{一切对用户 ( 程序员 ) 透明的资源标识都可以看作句柄}$**
>- 用户使用 `文件描述符` ( 句柄 ) 与内核交互
>- 内核通过 `文件描述符` ( 句柄 ) 操作对应资源的数据结构

## 1.3 一切皆文件的意义

>- 统一各种设备的操作方式 (open, read, write, close)
>- 一如 : 
>   - 10设备 (命令行 , 显示器)
>   - 网络设备 (网卡)
>

## 1.4 Linux文件操作编程模式

><img src="./assets/image-20230812212448578.png" alt="image-20230812212448578" />

## 1.5 编程实验

>[[参考链接🔗]](https://github.com/WONGZEONJYU/STU_LINUX_NETWORK/blob/main/5.fd_operator/fd_operator.cpp)
>
>```c++
>#include <cstdio>
>#include <unistd.h>
>#include <iostream>
>
>using namespace std;
>
>int main()
>{
>    int iofd {0};
>
>    char s[] {"Hello World!\r\n"};
>
>    write(iofd,s,sizeof(s));
>
>    int len (read(iofd,s,5));
>
>    s[len] = 0;
>
>    cout << "read : " << s << '\n';
>
>    return 0;
>}
>
>```
>
><img src="./assets/image-20230812213206678.png" alt="image-20230812213206678" />

# 2. 事件处理

### 2.1 事件相关函数的分类

#### 2.1.1 阻塞式函数

>- 函数调用后需要 **$\color{red}{等待}$** 某个事件发生后才会返回
>- `read(...)` , `scanf(...)` , `accept(...)`

#### 2.1.2 非阻塞式函数

> - 函数调用后能够及时返回 (**$\color{red}{仅标记等待的事件}$**)
> - 事件发生后以 **$\color{red}{回调方式}$** 传递

### 2.2 阻塞 VS 轮询

>- 轮询指依序询问每一个相关设备是否需要服务的方式
>- 轮询可用于解决阻塞函数导致程序无法继续执行的问题
>
><img src="./assets/image-20230812215304167.png" alt="image-20230812215304167" />

# 3. 关于`select(...)`

### 3.1 select(...) 函数

>- select(...) 用于监视指定的文件描述符是否产生事件
>- 可通过轮询的方式检测目标事件 (事件产生则标记发生变化)
>- 根据事件类型做出具体处理 (如 : 读取数据)
>
><img src="./assets/image-20230812222556951.png" alt="image-20230812222556951" />