# 十四、网络通信框架的完善

问题 : 如何扩展之前开发的通信框架 , 使其支持 `UDP` 通信 , 进而成为一个完善的网络通信框架 ? 

# 1.`UDP` 通信扩展

><img src="./assets/image-20230911155210019.png" alt="image-20230911155210019" />
>
>

# 2.`UDP` 通信实体概要设计

>- 每个 `UDP Point` 地位对等 , 可通过 `IP` 地址 和 `Port` 号进行通信
>- `UDP Point` 数据收发单位为 : `Message` 或 `Byte`
>- 在接口设计上 , 与 `TcpClient` 保持一致（框架接口一致性）
>- **$\color{red}{目标 : 封装原生 socket 细节 , 关注 UDP 通信逻辑}$**
>
><img src="./assets/image-20230911155507738.png" alt="image-20230911155507738" />

# 3. `UDP` 通信实体接口设计

><img src="./assets/image-20230911155949976.png" alt="image-20230911155949976" />

# 4. 关键代码实现

## 4.1 初始化

><img src="./assets/image-20230911161541174.png" alt="image-20230911161541174" />

## 4.2 消息接收

>- 由于 `UDP` 是以 **数据报** 方式进行通信 ( 非数据流方式 , 报文间有明显边界 )
>- 因此 , **$\color{red}{不能直接通过}$** `MParser_ ReadFd(...)` **$\color{red}{解析出消息}$**
>- 必须先将报文完整接收到内存中 , 再进行从内存中解析出消息
>- 即通过 `MParser_ReadMem(….)` 间接完成消息解析
>
>问题 : 如何知道 `UDP` 报文长度 ?
>
>- 通过 `MSG_PEEK` 去窥探一下当前接收了多少数据
>
>

